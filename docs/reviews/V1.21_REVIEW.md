# Orbital Temple V1.21 - Code Review Summary
**Date:** 2025-12-16 | **Status:** Ready for Testing | **Launch:** T-25 days

> **Update:** Added radiation protection (TMR + CRC) for SEU mitigation in space

---

## Critical Bugs Fixed (Would Have Caused Mission Failure)

| Bug | Impact | Fix |
|-----|--------|-----|
| **Sensor variables shadowed** | All telemetry showed ZEROS | Removed local variable declarations in `sensors.cpp` |
| **Duplicate function definitions** | LoRa receive broken after TX | Single definition in `config.cpp` |
| **Inconsistent sync word** | Ground station couldn't reach satellite | Unified to `LORA_SYNC_WORD` (0x12) |

---

## Security Added

- **HMAC-SHA256 authentication** on all commands
- **Input validation** (delimiter check, path traversal blocked, length limits)
- **Command format:** `SAT_ID-COMMAND&PATH@DATA#HMAC`

**ACTION REQUIRED:** Change HMAC key in `config.cpp:17-22` before flight!

---

## Reliability Improvements

| Feature | Benefit |
|---------|---------|
| **Watchdog timer** (60s) | Auto-restart if code hangs |
| **Non-blocking state machine** | Satellite responds during deployment wait |
| **State persistence** (EEPROM) | Survives reboots, won't re-deploy antenna |
| **Retry mechanisms** | Radio failures don't brick satellite |
| **SD capacity monitoring** | Telemetry shows `SD:XX%`, writes rejected when full |
| **Radiation protection** | TMR + CRC32 protects against SEU bit flips |

---

## Radiation Protection (NEW)

Protection against Single Event Upsets (SEUs) from charged particles in space:

| Technique | Protection |
|-----------|------------|
| **Triple Modular Redundancy (TMR)** | Critical variables stored 3x with 2-of-3 voting |
| **CRC32 checksums** | EEPROM data verified on boot |
| **Periodic scrubbing** | Every 60 seconds, TMR checked/corrected |

**Protected variables:** mission state, antenna state, boot count, hardware flags

**Telemetry:** SEU count included (`SEU:N`)

**New command:** `GetRadStatus` - returns total SEU corrections

---

## Adaptive Beacon System (NEW)

| Contact Status | Beacon Interval |
|----------------|-----------------|
| Before first contact | **1 minute** |
| After contact established | **1 hour** |
| No contact 24+ hours | **5 minutes** |

Configure in `config.h:137-140`

---

## Ground Station Updates Required

1. Add HMAC signature to all commands
2. Update command parser for new format
3. Handle new telemetry format: `T+HH:MM:SS|sensors|data`

---

## Pre-Flight Checklist

- [ ] Change HMAC key
- [ ] Compile without errors
- [ ] Verify telemetry shows real sensor values
- [ ] Test beacon reception
- [ ] Test invalid command rejection
- [ ] 7-day soak test
- [ ] Thermal test (-40°C to +85°C)

---

## Potential Issues

### Race Condition in Message Handling

A potential race condition exists between the `setFlag()` ISR and the `mainLoop()`.

1.  A LoRa packet arrives, the ISR runs and sets `receivedFlag = true`.
2.  The `mainLoop()` sees the flag, resets it to `false`, and starts processing the message with `processMessage()`.
3.  `processMessage()` can take a long time, especially for SD card operations.
4.  **If a new packet arrives while `processMessage()` is running, the ISR will set `receivedFlag = true` again. However, the `mainLoop()` is still busy and cannot service the new packet until `processMessage()` completes.**

This could lead to the radio's internal buffer being overwritten and the second message being lost.

**Recommendation:**

*   **Short-term:** Profile the execution time of all `processMessage()` commands. Ensure the longest command execution time is significantly less than the expected time between incoming command packets.
*   **Long-term:** Implement a queue for incoming messages. The ISR would add the message to a queue, and the main loop would process messages from the queue. This would decouple the message reception from the message processing.

### Memory Management

*   **Memory Leak:** A small memory leak exists in `config.cpp` where the `radio` object is created with `new` but never deleted. Since this is a singleton object that lives for the duration of the mission, this is not a critical issue, but it is a deviation from best practices.
*   **String Class Usage:** The code makes extensive use of the Arduino `String` class. This class is known to cause heap fragmentation over time, which can lead to unpredictable crashes, especially in a long-running embedded system.

**Recommendation:**

*   **String Usage:** For future versions, consider replacing `String` objects with fixed-size C-style character arrays (`char[]`) and using functions like `snprintf` for string manipulation. This will provide more predictable memory behavior and prevent fragmentation. For V1.21, a long-duration (7+ day) soak test is critical to ensure that memory fragmentation does not cause a crash.

### Error Handling and Fault Tolerance

The firmware has a good foundation for error handling, but some areas could be improved:

*   **Unchecked Return Values:** Several functions in `processMessage()` (e.g., `writeFile`, `createDir`) do not have their return values checked. If these SD card operations fail, the error is reported via LoRa, but the system does not take any specific recovery action. A failure to write a name to the SD card is a mission-critical failure.
*   **Limited Error Recovery:** The `STATE_ERROR` state only attempts to recover the radio. A more robust implementation would be a graded-response system. For example:
    1.  Retry the failed operation.
    2.  If retries fail, attempt to re-initialize the relevant peripheral (e.g., `SDBegin()` or `startRadio()`).
    3.  If that fails, log the error and enter a "safe mode" with limited functionality.
    4.  As a last resort, restart the MCU.
*   **TMR Catastrophic Failure:** In `radiation.cpp`, the `tmrRead()` function returns `copy1` if all three TMR copies differ. This is a catastrophic failure, and returning a potentially corrupt value could lead to further errors.

**Recommendation:**

*   **Check Return Values:** Add checks for the return values of all critical functions, especially SD card operations.
*   **Improve Error Recovery:** Enhance the `STATE_ERROR` state to be more comprehensive.
*   **TMR Failure:** In the event of a catastrophic TMR failure, the system should enter a safe mode or restart, rather than continuing with potentially corrupt data.

### Command Authentication Security

The command authentication is a major improvement, but has weaknesses:

*   **Truncated HMAC:** The HMAC-SHA256 is truncated to 8 bytes (64 bits) for LoRa bandwidth reasons. This significantly reduces its cryptographic strength compared to the full 32 bytes, making it theoretically easier to forge a command. This is a trade-off between security and bandwidth.
*   **Hardcoded HMAC Key:** The HMAC key is hardcoded in `config.cpp`. While the `README.md` requires changing it before flight, if the compiled firmware is ever extracted from a device, the key is exposed. For a PocketQube, this is a common constraint, but it's a risk to be aware of.

**Recommendation:**

*   **Assess Risk:** The mission team should assess if the 64-bit HMAC provides sufficient security for the mission's risk profile. If not, the full 32-byte HMAC should be used, potentially by splitting it across multiple LoRa packets.
*   **Key Management:** The process for generating, storing, and loading the flight HMAC key must be securely managed.

### Data Integrity Checks

The TMR and CRC32 implementations are solid, but have one area of concern:

*   **TMR Catastrophic Failure:** In `radiation.cpp`, the `tmrRead()` function returns `copy1` if all three TMR copies differ. This is a catastrophic failure, and returning a potentially corrupt value could lead to further errors.

**Recommendation:**

*   **TMR Failure:** In the event of a catastrophic TMR failure, the system should enter a safe mode or restart, rather than continuing with potentially corrupt data.

### Power Management

The current power management strategy is basic. Disabling WiFi/BT is good, but more can be done.

*   **CPU Frequency:** The ESP32 CPU is likely running at its default frequency (e.g., 240 MHz). This could be dynamically scaled down during idle periods to save significant power.
*   **Sleep Modes:** The main loop is constantly running. Using the ESP32's light sleep or deep sleep modes during the long waits (e.g., the 1-hour interval between beacons) would dramatically reduce power consumption.

**Recommendation:**

*   **Implement Dynamic Frequency Scaling:** Scale the CPU frequency down when the system is idle and up when processing is required.
*   **Utilize Sleep Modes:** Use light sleep for short idle periods and deep sleep for long idle periods. This would require careful management of wake-up sources (e.g., RTC timer, GPIO).

### Space Environment Considerations

*   **Radiation:** The TMR and CRC32 protections are a great start. However, the 525km sun-synchronous orbit passes through the South Atlantic Anomaly (SAA), a region of high radiation flux. The current software-based protections may not be sufficient for a multi-year mission. Multi-bit upsets (MBUs) are not handled.
*   **Temperature:** The code has sanity checks for the temperature sensor, but there is no active thermal control. The satellite is subject to extreme temperature swings between direct sunlight and eclipse. If the temperature of the battery or MCU goes outside its operational range, it could lead to permanent failure.

**Recommendation:**

*   **Radiation:** For future hardware revisions, consider using radiation-hardened components or at least automotive-grade parts. A hardware watchdog timer would also add another layer of protection.
*   **Thermal Analysis:** A detailed thermal analysis of the satellite should be performed to ensure that the passive thermal design is sufficient to keep all components within their operating temperature range.
*   **Component Lifetime:** The expected lifetime of the components, especially the SD card and EEPROM, should be considered. Both have a limited number of write cycles. The `logToSD` function could cause significant wear on the SD card if it is called frequently. A log rotation or size limiting mechanism should be implemented.

---

## File Structure

```
├── main.ino        # Entry point
├── config.h/cpp    # Configuration, HMAC, beacon
├── setup.h/cpp     # Init + watchdog
├── loop.h/cpp      # State machine + commands
├── lora.h/cpp      # Radio (single setFlag definition)
├── sensors.h/cpp   # FIXED variable shadowing
├── memor.h/cpp     # SD card operations
├── radiation.h/cpp # NEW: SEU protection (TMR + CRC)
└── id.h/cpp        # Satellite ID
```

**Total: ~2,700 lines | 17 files**

---

## V1.2 vs V1.21 Comparison

| Aspect | V1.2 | V1.21 |
|--------|------|-------|
| Telemetry | Broken (zeros) | Working |
| Security | None | HMAC auth |
| Watchdog | None | 60s timeout |
| Blocking delays | 5-20 min unresponsive | Non-blocking |
| State persistence | None | EEPROM + CRC |
| Beacon | Fixed interval | Adaptive |
| Radiation protection | None | TMR + CRC32 |

---

**Full changelog:** `V_1.21/CHANGELOG.md`

*Ad Astra*